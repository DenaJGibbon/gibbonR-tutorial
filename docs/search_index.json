[["part-3.-calculate-performance-metrics.html", "4 Part 3. Calculate performance metrics 4.1 Part 3a. Load libraries and specify file paths 4.2 Part 3b. Match detections with human annotations 4.3 Part 3c. Calculate performance metrics 4.4 3d. Plot the results", " 4 Part 3. Calculate performance metrics 4.1 Part 3a. Load libraries and specify file paths Please note this script is very much in development! # Load necessary libraries library(stringr) # For string manipulation library(caret) # For machine learning and model evaluation library(ggpubr) # For data visualization library(dplyr) # For data manipulation library(data.table) # For sorting the detections library(ggplot2) # For data visualization # Change this so that it points to the location on your computer FolderPath &lt;- &#39;/Users/denaclink/Library/CloudStorage/Box-Box/gibbonRSampleFiles/&#39; # Get a list of TopModel result files TopModelresults &lt;- list.files(&#39;data/DetectAndClassifyOutput&#39;, full.names = TRUE) # Get a list of annotation selection table files TestDataSet &lt;- list.files( paste(FolderPath,&quot;/SelectionTables/GibbonTestSelectionTables&quot;, sep=&#39;&#39;), full.names = TRUE) 4.2 Part 3b. Match detections with human annotations Now we match the detections from the model to human annotations. The start time/end time buffer tells us how much flexibility the detections can have from the start/end time of the call. If the calls are short, then this should be short. start.time.buffer &lt;- 8 end.time.buffer &lt;- 4 # Preallocate space for TopModelDetectionDF TopModelDetectionDF &lt;- data.frame() # Loop through each TopModel result file for (f in 1:length(TopModelresults)) { # Read the TopModel result table into a data frame TempTopModelTable &lt;- read.delim2(TopModelresults[f]) # Extract the short name of the TopModel result file ShortName &lt;- basename(TopModelresults[f]) ShortName &lt;- str_split_fixed(ShortName, pattern = &#39;gibbonR&#39;, n = 2)[, 1] # Find the corresponding annotation selection table testDataIndex &lt;- which(str_detect(TestDataSet, ShortName)) if(length(testDataIndex) &gt; 0 ){ TestDataTable &lt;- read.delim2(TestDataSet[testDataIndex]) # Round Begin.Time..s. and End.Time..s. columns to numeric TestDataTable$Begin.Time..s. &lt;- round(as.numeric(TestDataTable$Begin.Time..s.)) TestDataTable$End.Time..s. &lt;- round(as.numeric(TestDataTable$End.Time..s.)) DetectionList &lt;- list() # Loop through each row in TempTopModelTable for (c in 1:nrow(TempTopModelTable)) { TempRow &lt;- TempTopModelTable[c,] # Check if Begin.Time..s. is not NA if (!is.na(TempRow$Begin.Time..s.)) { # Convert Begin.Time..s. and End.Time..s. to numeric TempRow$Begin.Time..s. &lt;- as.numeric(TempRow$Begin.Time..s.) TempRow$End.Time..s. &lt;- as.numeric(TempRow$End.Time..s.) # Determine if the time of the detection is within the time range of an annotation TimeBetween &lt;- data.table::between(TempRow$Begin.Time..s., TestDataTable$Begin.Time..s. - start.time.buffer, TestDataTable$End.Time..s. + end.time.buffer) # Extract the detections matching the time range matched_detections &lt;- TestDataTable[TimeBetween, ] if (nrow(matched_detections) &gt; 0) { # Set signal based on the Call.Type in matched_detections TempRow$signal &lt;- &#39;female.gibbon&#39; DetectionList[[length( unlist(DetectionList))+1]] &lt;- which(TimeBetween == TRUE) } else { # Set signal to &#39;Noise&#39; if no corresponding annotation is found TempRow$signal &lt;- &#39;noise&#39; } # Append TempRow to TopModelDetectionDF TopModelDetectionDF &lt;- rbind.data.frame(TopModelDetectionDF, TempRow) } } # Identify missed detections if (length( unlist(DetectionList)) &gt; 0 &amp; length( unlist(DetectionList)) &lt; nrow(TestDataTable) ) { missed_detections &lt;- TestDataTable[-unlist(DetectionList), ] # Prepare missed detections data missed_detections &lt;- missed_detections[, c(&quot;Selection&quot;, &quot;View&quot;, &quot;Channel&quot;, &quot;Begin.Time..s.&quot;, &quot;End.Time..s.&quot;, &quot;Low.Freq..Hz.&quot;, &quot;High.Freq..Hz.&quot;)] missed_detections &lt;- missed_detections missed_detections$File.Name &lt;- ShortName missed_detections$model.type &lt;- &#39;SVM&#39; missed_detections$probability &lt;- 0 missed_detections$signal &lt;- &#39;female.gibbon&#39; # Append missed detections to TopModelDetectionDF TopModelDetectionDF &lt;- rbind.data.frame(TopModelDetectionDF, missed_detections) } if (length( unlist(DetectionList)) == 0) { missed_detections &lt;- TestDataTable # Prepare missed detections data missed_detections &lt;- missed_detections missed_detections$File.Name &lt;- ShortName missed_detections$model.type &lt;- &#39;SVM&#39; missed_detections$probability &lt;- 0 missed_detections$signal &lt;- &#39;female.gibbon&#39; # Append missed detections to TopModelDetectionDF TopModelDetectionDF &lt;- rbind.data.frame(TopModelDetectionDF, missed_detections) } } } # Check the resulting structure head(TopModelDetectionDF) ## Selection View Channel Begin.Time..s. End.Time..s. Low.Freq..Hz. ## 1 1 Spectrogram 1 1 108.404 119.474 400 ## 2 2 Spectrogram 1 1 126.334 135.085 400 ## 3 3 Spectrogram 1 1 135.125 144.125 400 ## 4 4 Spectrogram 1 1 166.456 176.316 400 ## 5 5 Spectrogram 1 1 208.497 220.857 400 ## 6 6 Spectrogram 1 1 270.979 284.060 400 ## High.Freq..Hz. File.Name model.type probability signal ## 1 1600 S11_20180217_080003 SVM 0.221 noise ## 2 1600 S11_20180217_080003 SVM 0.292 noise ## 3 1600 S11_20180217_080003 SVM 0.751 female.gibbon ## 4 1600 S11_20180217_080003 SVM 0.712 female.gibbon ## 5 1600 S11_20180217_080003 SVM 0.376 female.gibbon ## 6 1600 S11_20180217_080003 SVM 0.315 female.gibbon # Create table of signals table(TopModelDetectionDF$signal) ## ## female.gibbon noise ## 23 8 4.3 Part 3c. Calculate performance metrics Now that we have matched annotations and detections we can calculate performance over a number of thresholds # Convert signal column to a factor variable TopModelDetectionDF$signal &lt;- as.factor(TopModelDetectionDF$signal) # Display unique values in the signal column unique(TopModelDetectionDF$signal) ## [1] noise female.gibbon ## Levels: female.gibbon noise # Define a vector of confidence Thresholds Thresholds &lt;-seq(0.1,1,0.1) # Create an empty data frame to store results BestF1data.framefemale.gibbonBinary &lt;- data.frame() # Loop through each threshold value for(a in 1:length(Thresholds)){ # Filter the subset based on the confidence threshold TopModelDetectionDF_single &lt;-TopModelDetectionDF TopModelDetectionDF_single$Predictedsignal &lt;- ifelse(TopModelDetectionDF_single$probability &lt;=Thresholds[a], &#39;noise&#39;,&#39;female.gibbon&#39;) # Calculate confusion matrix using caret package caretConf &lt;- caret::confusionMatrix( as.factor(TopModelDetectionDF_single$Predictedsignal), as.factor(TopModelDetectionDF_single$signal),positive = &#39;female.gibbon&#39;, mode = &#39;everything&#39;) # Extract F1 score, Precision, and Recall from the confusion matrix F1 &lt;- caretConf$byClass[7] Precision &lt;- caretConf$byClass[5] Recall &lt;- caretConf$byClass[6] FP &lt;- caretConf$table[1,2] TN &lt;- sum(caretConf$table[2,])#+JahooAdj FPR &lt;- FP / (FP + TN) # Create a row for the result and add it to the BestF1data.frameGreyfemale.gibbon #TrainingData &lt;- training_data_type TempF1Row &lt;- cbind.data.frame(F1, Precision, Recall,FPR) TempF1Row$Thresholds &lt;- Thresholds[a] BestF1data.framefemale.gibbonBinary &lt;- rbind.data.frame(BestF1data.framefemale.gibbonBinary, TempF1Row) } 4.4 3d. Plot the results We can plot precision, recall, and F1 as a function of the model confidence or threshold. Note that we would not expect really great performance, as we only have a small number of training samples. female.gibbonMax &lt;- round(max(na.omit(BestF1data.framefemale.gibbonBinary$F1)),2) # Metric plot female.gibbonBinaryPlot &lt;- ggplot(data = BestF1data.framefemale.gibbonBinary, aes(x = Thresholds)) + geom_line(aes(y = F1, color = &quot;F1&quot;, linetype = &quot;F1&quot;)) + geom_line(aes(y = Precision, color = &quot;Precision&quot;, linetype = &quot;Precision&quot;)) + geom_line(aes(y = Recall, color = &quot;Recall&quot;, linetype = &quot;Recall&quot;)) + labs(title = paste(&quot;Female gibbon automated detection (binary) \\n max F1:&quot;,female.gibbonMax), x = &quot;Confidence&quot;, y = &quot;Values&quot;) + scale_color_manual(values = c(&quot;F1&quot; = &quot;blue&quot;, &quot;Precision&quot; = &quot;red&quot;, &quot;Recall&quot; = &quot;green&quot;), labels = c(&quot;F1&quot;, &quot;Precision&quot;, &quot;Recall&quot;)) + scale_linetype_manual(values = c(&quot;F1&quot; = &quot;dashed&quot;, &quot;Precision&quot; = &quot;dotted&quot;, &quot;Recall&quot; = &quot;solid&quot;)) + theme_minimal() + theme(legend.title = element_blank())+ labs(color = &quot;Guide name&quot;, linetype = &quot;Guide name&quot;, shape = &quot;Guide name&quot;) female.gibbonBinaryPlot "]]
