[["index.html", "gibbonR: An R package for the automated detection and classification of female gibbon calls from long-term acoustic recordings 1 Getting started 1.1 You can install the development version from GitHub with:", " gibbonR: An R package for the automated detection and classification of female gibbon calls from long-term acoustic recordings Dena J. Clink 2022-10-15 1 Getting started 1.1 You can install the development version from GitHub with: # install.packages(&quot;devtools&quot;) # devtools::install_github(&quot;DenaJGibbon/gibbonR&quot;) library(gibbonR) "],["part-1.-prepare-training-data.html", "2 Part 1. Prepare Training Data 2.1 Part 1A. Training Data with Labeled .wav clips 2.2 Part 1B. Training Data with Raven Selection Tables", " 2 Part 1. Prepare Training Data In ‘gibbonR’ there are two ways that you can format your training data. The first can be a set of labelled .wav clips with the class indicated in the name of the file (e.g., ‘gibbon_01.wav’ and ‘noise_01.wav’). The second is to have a folder of selection tables created in Raven Pro (K. Lisa Yang Center for Conservation Bioacoustics) and a folder with the associated ‘.wav’ files. For the second approach there must be an annotation column indicating the call type and it is assumed that all signals of interest are annotated, and the rest of the files contain only background noise. 2.1 Part 1A. Training Data with Labeled .wav clips 2.1.1 Read in clips and calculate MFCCs TrainingWavFilesDir &lt;- &quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/MultipleSoundClasses/&quot; trainingdata &lt;- gibbonR::MFCCFunction(input.dir=TrainingWavFilesDir, min.freq = 400, max.freq = 1600,win.avg=&quot;TRUE&quot;) trainingdata$class &lt;- as.factor(trainingdata$class) 2.1.2 Compare Random Forest and Support Vector Machine for Supervised Classification trainingdata$class &lt;- as.factor(trainingdata$class) ml.model.svm &lt;- e1071::svm(trainingdata[, 2:ncol(trainingdata)], trainingdata$class, kernel = &quot;radial&quot;, cross = 25, probability = TRUE) print(paste(&#39;SVM accuracy&#39;,ml.model.svm$tot.accuracy)) #&gt; [1] &quot;SVM accuracy 88&quot; ml.model.rf &lt;- randomForest::randomForest(x=trainingdata[, 2:ncol(trainingdata)], y = trainingdata$class) print(ml.model.rf) #&gt; #&gt; Call: #&gt; randomForest(x = trainingdata[, 2:ncol(trainingdata)], y = trainingdata$class) #&gt; Type of random forest: classification #&gt; Number of trees: 500 #&gt; No. of variables tried at each split: 13 #&gt; #&gt; OOB estimate of error rate: 10.67% #&gt; Confusion matrix: #&gt; female.gibbon leaf.monkey noise solo.gibbon class.error #&gt; female.gibbon 17 0 1 2 0.15 #&gt; leaf.monkey 0 12 3 0 0.20 #&gt; noise 0 0 19 1 0.05 #&gt; solo.gibbon 0 1 0 19 0.05 2.2 Part 1B. Training Data with Raven Selection Tables 2.2.1 Prepare training data from labeled annotations # Specify the folder where the training data will be saved TrainingDataFolderLocation &lt;- &quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/TrainingDataFromRavenSelectionTables&quot; # Directory with annotated selection tables AnnotatedSelectionTables &lt;- list.files(&quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/SelectionTables/GibbonTrainingSelectionTables/&quot;, full.names = T) # Directory with corresponding .wav files AnnotatedWaveFiles &lt;- list.files(&quot;/Users/denaclink/Library/CloudStorage/Box-Box/gibbonRSampleFiles/GibbonTrainingFiles/&quot;,full.names = T) AnnotatedWaveFilesShort &lt;- list.files(&quot;/Users/denaclink/Library/CloudStorage/Box-Box/gibbonRSampleFiles/GibbonTrainingFiles/&quot;,full.names = F) AnnotatedWaveFilesShort &lt;- str_split_fixed(AnnotatedWaveFilesShort,pattern = &#39;.wav&#39;, n=2)[,1] # Loop to cut out the corresponding annotations into short clips for(i in 1: length(AnnotatedSelectionTables)){ # Read in selection table TempSelectionTable &lt;- read.delim2(AnnotatedSelectionTables[i]) # Find the corresponding soundfile SoundFileIndex &lt;- which(str_detect(AnnotatedSelectionTables[i],AnnotatedWaveFilesShort)) TempAnnotateWave &lt;- readWave(AnnotatedWaveFiles[SoundFileIndex]) ShortSoundClips &lt;- lapply(1:nrow(TempSelectionTable), function(j) extractWave(TempAnnotateWave, from= as.numeric(TempSelectionTable[j,]$Begin.Time..s.), to=as.numeric(TempSelectionTable[j,]$ End.Time..s.), xunit = c(&quot;time&quot;),plot=F,output=&quot;Wave&quot;)) # Write wave files to folder for(k in 1:length(ShortSoundClips)){ TempClip &lt;- ShortSoundClips[[k]] WavFileName &lt;- paste(TrainingDataFolderLocation,&#39;/female.gibbon_&#39;, k, &#39;.wav&#39;,sep=&quot;&quot;) writeWave(TempClip,WavFileName,extensible = F) } } 2.2.2 Prepare noise training data from files without target signal # Specify the folder where the training data will be saved TrainingDataFolderLocation &lt;- &quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/TrainingDataFromRavenSelectionTables/&quot; # Directory with annotated selection tables NoiseSelectionTables &lt;- list.files(&quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/SelectionTables/NoiseSelectionTables/&quot;, full.names = T) # Directory with corresponding .wav files NoiseWaveFiles &lt;- list.files(&quot;/Users/denaclink/Library/CloudStorage/Box-Box/gibbonRSampleFiles/NoiseFiles/&quot;,full.names = T) NoiseWaveFilesShort &lt;- list.files(&quot;/Users/denaclink/Library/CloudStorage/Box-Box/gibbonRSampleFiles/NoiseFiles/&quot;,full.names = F) NoiseWaveFilesShort &lt;- str_split_fixed(NoiseWaveFilesShort,pattern = &#39;.wav&#39;, n=2)[,1] for(i in 1:length(NoiseSelectionTables)){ # Find the corresponding soundfile SoundFileIndex &lt;- which(str_detect(NoiseSelectionTables[i],NoiseWaveFilesShort)) DetectBLED(input=NoiseWaveFiles[SoundFileIndex], min.freq = 400, max.freq = 1600, noise.quantile.val=0.3, file.type=&#39;wav&#39;, spectrogram.window =512, pattern.split = &quot;.wav&quot;, min.signal.dur = 3, max.sound.event.dur = 12, output = &quot;wav&quot;, wav.output = &quot;TRUE&quot;, output.dir = TrainingDataFolderLocation, swift.time=TRUE, time.start=06, time.stop=11, write.csv.output=TRUE, verbose=TRUE, random.sample=FALSE) } 2.2.3 Now read in clips based on Raven Selection tables and calculate MFCCs TrainingWavFilesDir &lt;- &quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/TrainingDataFromRavenSelectionTables/&quot; trainingdata &lt;- gibbonR::MFCCFunction(input.dir=TrainingWavFilesDir, min.freq = 400, max.freq = 1600,win.avg=&quot;TRUE&quot;) trainingdata$class &lt;- as.factor(trainingdata$class) 2.2.4 Compare Random Forest and Support Vector Machine for Supervised Classification trainingdata$class &lt;- as.factor(trainingdata$class) ml.model.svm &lt;- e1071::svm(trainingdata[, 2:ncol(trainingdata)], trainingdata$class, kernel = &quot;radial&quot;, cross = 25, probability = TRUE) print(paste(&#39;SVM accuracy&#39;,ml.model.svm$tot.accuracy)) #&gt; [1] &quot;SVM accuracy 98.1132075471698&quot; ml.model.rf &lt;- randomForest::randomForest(x=trainingdata[, 2:ncol(trainingdata)], y = trainingdata$class) print(ml.model.rf) #&gt; #&gt; Call: #&gt; randomForest(x = trainingdata[, 2:ncol(trainingdata)], y = trainingdata$class) #&gt; Type of random forest: classification #&gt; Number of trees: 500 #&gt; No. of variables tried at each split: 13 #&gt; #&gt; OOB estimate of error rate: 3.77% #&gt; Confusion matrix: #&gt; female.gibbon noise class.error #&gt; female.gibbon 24 2 0.07692308 #&gt; noise 0 27 0.00000000 "],["part-2.-run-the-detectorclassifier.html", "3 Part 2. Run the detector/classifier 3.1 Part 2a. Feature extraction 3.2 Part 2b. Run DetectClassify", " 3 Part 2. Run the detector/classifier 3.1 Part 2a. Feature extraction # Specify the folder where the training data will be saved TrainingDataFolderLocation &lt;- &quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/TrainingDataFromRavenSelectionTables/&quot; TrainingDataMFCC &lt;- MFCCFunction(input.dir= TrainingDataFolderLocation, min.freq = 400, max.freq = 1600,win.avg=&quot;TRUE&quot;) TrainingDataMFCC$class &lt;- as.factor(TrainingDataMFCC$class) 3.2 Part 2b. Run DetectClassify TestFileDirectory &lt;- &#39;/Users/denaclink/Library/CloudStorage/Box-Box/gibbonRSampleFiles/GibbonTestFiles&#39; OutputDirectory &lt;- &quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/DetectAndClassifyOutput&quot; DetectAndClassify(input=TestFileDirectory, input.type=&#39;directory&#39;, feature.df=TrainingDataMFCC, model.type.list=c(&#39;SVM&#39;,&#39;RF&#39;), tune = TRUE, short.wav.duration=300, target.signal = c(&quot;female.gibbon&quot;), min.freq = 400, max.freq = 1600, noise.quantile.val=0.15, time.window.number =3, n.windows = 9, num.cep = 12, spectrogram.window =160, pattern.split = &quot;.wav&quot;, min.signal.dur = 3, max.sound.event.dur = 25, maximum.separation =1, probability.thresh.svm = 0.15, probability.thresh.rf = 0.15, wav.output = &quot;TRUE&quot;, output.dir =OutputDirectory, swift.time=TRUE,time.start=5,time.stop=10, write.csv.output=FALSE,verbose=TRUE, random.sample=&#39;NA&#39;) #&gt; [1] &quot;Machine learning in progress...&quot; #&gt; [1] &quot;SVM in progress...&quot; #&gt; [1] &quot;SVM accuracy 98.1132075471698&quot; #&gt; Time difference of 1.589375 secs #&gt; [1] &quot;RF in progress...&quot; #&gt; #&gt; Call: #&gt; randomForest(x = feature.df[, 2:ncol(feature.df)], y = feature.df$class) #&gt; Type of random forest: classification #&gt; Number of trees: 500 #&gt; No. of variables tried at each split: 13 #&gt; #&gt; OOB estimate of error rate: 9.43% #&gt; Confusion matrix: #&gt; female.gibbon noise class.error #&gt; female.gibbon 23 3 0.11538462 #&gt; noise 2 25 0.07407407 #&gt; Time difference of 0.06244493 secs #&gt; [1] &quot;Classifying for target signal female.gibbon&quot; #&gt; [1] &quot;Computing spectrogram for file S11_20180217_080003 1 out of 1&quot; #&gt; [1] &quot;Running detector over sound files&quot; #&gt; [1] &quot;Creating datasheet&quot; #&gt; [1] &quot;System processed 7201 seconds in 15 seconds this translates to 489.1 hours processed in 1 hour&quot; "],["part-3.-calculate-performance-metrics.html", "4 Part 3. Calculate performance metrics 4.1 Part 3a. Prepare data for performance metrics 4.2 Part 3b. Identify true and false positives 4.3 Part 3c. Calculate and plot performance metrics using ‘ROCR’", " 4 Part 3. Calculate performance metrics 4.1 Part 3a. Prepare data for performance metrics # Set location of test file selection tables input.dir.text.files &lt;- &quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/SelectionTables/GibbonTestSelectionTables&quot; Annotatedfiles &lt;- list.files(input.dir.text.files,full.names = T) ListOfAnnotatedFilesShort &lt;- list.files(input.dir.text.files,full.names = F) nslash &lt;- str_count(Annotatedfiles,pattern = &#39;/&#39;)[1]+1 snames &lt;- str_split_fixed(Annotatedfiles,pattern = &#39;/&#39;,n=nslash)[,nslash] all.detections &lt;- data.frame() for(x in 1:length(Annotatedfiles)){ temp.table &lt;- read.delim2(Annotatedfiles[x],fill = T,header =T) file.name &lt;- str_split_fixed(snames[x],pattern = &#39;[.]&#39;,n=2)[,1] recorder &lt;- str_split_fixed(file.name,pattern=&#39;_&#39;,n=3)[,1] date &lt;- str_split_fixed(file.name,pattern=&#39;_&#39;,n=3)[,2] time &lt;- str_split_fixed(file.name,pattern=&#39;_&#39;,n=3)[,3] if(nrow(temp.table &gt;0)){ temp.table.updated &lt;- cbind.data.frame(file.name,recorder,date,time,temp.table) } else { temp.row &lt;- as.data.frame(t(rep(&#39;NA&#39;,ncol(temp.table)))) colnames(temp.row) &lt;- colnames(temp.table) temp.table.updated &lt;- cbind.data.frame(file.name,recorder,date,time,temp.row) } all.detections &lt;- rbind.data.frame(all.detections,temp.table.updated) } 4.2 Part 3b. Identify true and false positives OutputDirectory &lt;- &quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/DetectAndClassifyOutput&quot; all.combinedprecision.recall.randomiter &lt;- data.frame() range.secs.start &lt;- 6 range.secs.end &lt;- 6 ### Detections using band-limited energy summation gibbondetects &lt;- OutputDirectory list.ml &lt;- list.files(gibbondetects, full.names = T, pattern=&#39;.wav&#39;) # Need to focus on gibbons for this validation nslash &lt;- str_count(list.ml[[1]],&#39;/&#39;)+1 list.ml.signals &lt;- str_split_fixed(list.ml,pattern = &#39;/&#39;,n=nslash)[,nslash] list.ml.signals &lt;- str_split_fixed(list.ml.signals,pattern = &#39;_&#39;,n=5)[,4] list.ml &lt;- list.ml[which(list.ml.signals==&#39;female.gibbon&#39;)] ml.detection.df &lt;- data.frame() for(y in 1:length(list.ml)){ L.wav &lt;- list.ml[[y]] n.slash &lt;- str_count(L.wav, pattern = &quot;/&quot;)[1] + 1 det.file.name &lt;- str_split_fixed(L.wav,&quot;/&quot;,n=n.slash)[,n.slash] det.file.name &lt;- str_split_fixed(det.file.name,&quot;.wav&quot;,n=2)[,1] file.name &lt;- paste(str_split_fixed(det.file.name,&quot;_&quot;,n=5)[,1],str_split_fixed(det.file.name,&quot;_&quot;,n=5)[,2], str_split_fixed(det.file.name,&quot;_&quot;,n=5)[,3], sep=&#39;_&#39;) det.date &lt;- str_split_fixed(det.file.name,&quot;_&quot;,n=5)[,2] det.time &lt;- str_split_fixed(det.file.name,&quot;_&quot;,n=5)[,3] det.swift &lt;- str_split_fixed(det.file.name,&quot;_&quot;,n=5)[,1] det.time.start &lt;- as.numeric(str_split_fixed(det.file.name,&quot;_&quot;,n=9)[,6]) det.time.end &lt;- as.numeric(str_split_fixed(det.file.name,&quot;_&quot;,n=9)[,7]) probability &lt;- str_split_fixed(det.file.name,&quot;_&quot;,n=8)[,8] ml.algorithm &lt;- str_split_fixed(det.file.name,&quot;_&quot;,n=7)[,5] detections.df &lt;- cbind.data.frame(file.name,det.swift, det.date, det.time,det.time.start,det.time.end,probability,ml.algorithm) ml.detection.df &lt;- rbind.data.frame(ml.detection.df,detections.df) } recall.snr.all.df &lt;- data.frame() for(x in 1:nrow(ml.detection.df)){ all.detections.subset &lt;- ml.detection.df[x,] validate.detect.subset &lt;-subset(all.detections,file.name==as.character(all.detections.subset$file.name)) validate.detect.subset$Begin.Time..s. &lt;- as.numeric(validate.detect.subset$Begin.Time..s.) min.start.time &lt;- as.numeric(all.detections.subset$det.time.start)-range.secs.start max.start.time &lt;- as.numeric(all.detections.subset$det.time.start)+range.secs.end detections.ml &lt;- subset(validate.detect.subset, Begin.Time..s.&gt;min.start.time &amp; Begin.Time..s.&lt; max.start.time) if(nrow(detections.ml)&gt;0){ all.detections.subset$class.label &lt;- &#39;1&#39; } else{ all.detections.subset$class.label &lt;- &#39;-1&#39; } recall.snr.all.df &lt;- rbind.data.frame(recall.snr.all.df,all.detections.subset) } 4.3 Part 3c. Calculate and plot performance metrics using ‘ROCR’ library(ROCR) auc.df &lt;- data.frame() performance.df &lt;- data.frame() ml.index &lt;- unique(recall.snr.all.df$ml.algorithm) for(m in 1:length(ml.index)){ temp.subset &lt;- subset(recall.snr.all.df, ml.algorithm==ml.index[m]) predictions &lt;- as.numeric(temp.subset$probability) labels &lt;- (temp.subset$class.label) pred &lt;- prediction(predictions, labels) perf &lt;- performance(pred, &quot;rec&quot;, &quot;prec&quot;) perfauc &lt;- performance(pred, &quot;aucpr&quot;) Precision &lt;- perf@x.values[[1]] Recall &lt;- perf@y.values[[1]] Threshold &lt;- perf@alpha.values[[1]] AUC &lt;- perfauc@y.values[[1]] perfF1 &lt;- performance(pred, &quot;f&quot;) F1 &lt;- perfF1@y.values[[1]] print(AUC) ml.algorithm &lt;- ml.index[m] tempauc &lt;- cbind.data.frame(AUC,ml.algorithm) auc.df &lt;- rbind.data.frame(auc.df,tempauc) temp.performance &lt;- cbind.data.frame(Precision,Recall,Threshold,F1,ml.algorithm) performance.df &lt;- rbind.data.frame(performance.df,temp.performance) perf &lt;- performance(pred, &quot;prec&quot;, &quot;rec&quot;) plot(perf, avg= &quot;threshold&quot;, colorize=TRUE, lwd= 3, main= paste(ml.index[m],&#39;Precision/Recall&#39;)) plot(perf, lty=3, col=&quot;grey78&quot;, add=TRUE) } #&gt; [1] 0.5858582 #&gt; [1] 0.9408489 "],["part-4.-data-visualization.html", "5 Part 4. Data visualization 5.1 Part 4a. Create a UMAP plot colored by class", " 5 Part 4. Data visualization 5.1 Part 4a. Create a UMAP plot colored by class library(gibbonR) library(ggpubr) UMAPBiplotAddSpectrograms(input.dir.Focal=&quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/MultipleSoundClasses/&quot;,output.dir.Focal=&quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/MultipleSoundClasses/Thumbnails/&quot;,add.spectrograms=TRUE,min.freq=400,max.freq=1600,main=&quot;UMAP Plot&quot;) #&gt; [1] &quot;Step 1 Calculating MFCCs&quot; #&gt; [1] &quot;Step 2 Creating biplot&quot; #&gt; [1] &quot;Step 3 Creating Spectrograms&quot; #&gt; [1] &quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/MultipleSoundClasses/Thumbnails/ already exists&quot; #&gt; [1] &quot;Step 4 Adding Spectrograms to Plot &quot; ## Part 4b. Create a UMAP plot colored by affinity propagation clustering library(gibbonR) library(ggpubr) library(apcluster) AffinityBiplotAddSpectrograms(input.dir.Focal=&quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/MultipleSoundClasses/&quot;,output.dir.Focal=&quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/MultipleSoundClasses/Thumbnails/&quot;,class=&#39;fixed&#39;, q.fixed=0.1,add.spectrograms=TRUE,min.freq=400,max.freq=1600,main=&quot;UMAP Plot&quot;) #&gt; [1] &quot;Step 1 Calculating MFCCs&quot; #&gt; [1] &quot;Step 2 Computing unsupervised clustering with fixed q&quot; #&gt; [1] &quot;Step 3 Creating Spectrograms &quot; #&gt; [1] &quot;/Users/denaclink/Desktop/RStudio Projects/gibbonR/data/MultipleSoundClasses/Thumbnails/ already exists&quot; #&gt; [1] &quot;Adding Spectrograms to Plot Step 3 of 3&quot; "]]
